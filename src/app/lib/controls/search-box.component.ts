import { ISearchService } from './ISearchService'; import { AfterViewInit, Component, ContentChild, ContentChildren, ElementRef, EventEmitter, Input, Output, QueryList, style, TemplateRef, ViewChild, ViewChildren } from '@angular/core'; import { OnInit } from '@angular/core'; import { FormControl } from '@angular/forms'; import { Http } from '@angular/http';  @Component({ selector: 'search-box', template: `  <div *ngIf="selectedItem != null" style="height: 0px;"> <div #selectedItemTemplate > <template  [ngTemplateOutlet]="template" [ngOutletContext]="{item: selectedItem}" ></template> </div> </div> <div class="input-group dropdown" [class.open]="areSuggestionsVisible">  <input type="text" class="form-control" typeahead="off" [formControl]="inputFilter" spellcheck="false" [readonly]="!enabled" (keyup)="inputKeyDown($event)" (blur) ="inputBlur($event)" >  <div class="dropdown-menu" (mouseout)="suggestionsMouseOut($event)">  <a href="javascript:void(0);"  *ngFor="let suggestion of itemsSource" class="dropdown-item" (mouseover)="suggestionMouseOver(suggestion)" (mousedown)="suggestionMouseDown(suggestion, $event)" [ngClass]="{'typeahead-suggestion-active': activeSuggestion===suggestion}">  <template [ngTemplateOutlet]="template" [ngOutletContext]="{item: suggestion}"></template>  </a>  </div> <span class="input-group-addon"><i class="fa fa-search"></i></span> </div>  `, styles: [` .typeahead-suggestion-active { background-color: #edf1f2; } `], providers: [] })    export class SearchBox implements OnInit, AfterViewInit { @ContentChild(TemplateRef) template: TemplateRef < any > ; /*@ViewChildren('suggestionItem') items: QueryList<ElementRef>;*/ @ViewChildren('selectedItemTemplate') selectedItemTemplate: QueryList < ElementRef > ;  inputFilter = new FormControl();  /* @Input() list: any[] = [];*/ @Input() searchService: ISearchService < any, any > ; @Input() selectedItem: any; @Input() enabled: boolean = true; @Input() searchParam: any;  @Input() enableLog: boolean = false; @Output() OnSelectionChanged = new EventEmitter < any > (); @Output() OnClearedSelectedItem = new EventEmitter(); private areSuggestionsVisible: boolean = false;   private selectedItemText: string = '';  private activeSuggestion: any; private itemsSource: Array < any > ; private currentIndex: number = -1;   constructor(private http: Http) {}  public ngAfterViewInit() {  this.selectedItemTemplate.changes.subscribe(() => { this.Log('query template changed', this.selectedItemTemplate); if (this.selectedItem !== null) { let list = this.selectedItemTemplate.map(a => { return a; }); this.selectedItemText = ( < HTMLElement > list[0].nativeElement).innerText; this.inputFilter.setValue(this.selectedItemText); } else { this.Log('Selected sugestion NULL - query template changed'); }  }  );  this.Log('query template:', this.selectedItemTemplate); }  public ngOnInit() { this.inputFilter.valueChanges. debounceTime(400) .distinctUntilChanged() .subscribe(filter => this.filterChanged(filter)); }  public filterChanged(filter: string) { if (filter !== '') { if (filter !== this.selectedItemText) { if (this.selectedItem !== null) this.selectSuggestion(null); this.searchService.search(filter, this.searchParam).subscribe(result => { this.itemsSource = result;  if (result != null && result.length > 0) { this.areSuggestionsVisible = true; } else { this.areSuggestionsVisible = false; } }); } } else { this.clearSelectedItem(); this.areSuggestionsVisible = false; this.Log('not calling service'); } }  public clearSelectedItem() { this.Log('cleared selected item'); if (this.inputFilter.value !== '') { this.inputFilter.setValue(''); }  this.selectSuggestion(null); this.selectedItemText = ''; }  /** * Called when a keydown event is fired on the input element. */ public inputKeyDown(event: KeyboardEvent) { /* if (event.which === 9 || event.keyCode === 9) {   TAB Only enter this branch if suggestions are displayed if (!this.areSuggestionsVisible) { return; }  Select the first suggestion this.selectSuggestion(this.activeSuggestion);  Remove all but the first suggestion this.suggestions.splice(1);  Hide the suggestions this.areSuggestionsVisible = false;  event.preventDefault(); } else */  if (event.which === 38 || event.keyCode === 38) { /* UP*/  this.currentIndex--; this.setActiveSuggestion(this.itemsSource[this.currentIndex]); /* Find the active suggestion in the list let activeSuggestionIndex = this.getActiveSuggestionIndex();  If not found, then activate the first suggestion if (activeSuggestionIndex === -1) { this.setActiveSuggestion(this.itemsSource[0]); return; }  if (activeSuggestionIndex === 0) { Go to the last suggestion this.setActiveSuggestion(this.itemsSource[this.itemsSource.length - 1]); } else { Decrement the suggestion index this.setActiveSuggestion(this.itemsSource[activeSuggestionIndex - 1]); } */ } else if (event.which === 40 || event.keyCode === 40) { /* DOWN*/ this.DownKeyPressed(); } else if ((event.which === 10 || event.which === 13 || event.keyCode === 10 || event.keyCode === 13) && this.areSuggestionsVisible) { this.EnterKeyPressed(); event.preventDefault(); } }  public EnterKeyPressed() { this.selectSuggestion(this.activeSuggestion); /* let activeSuggestion = this.getActiveSuggestionIndex();  Hide the suggestions var list = this.selectedSuggestionTemplate.map( a=> { return a;}); this.populateInputFilter(); */ this.areSuggestionsVisible = false; }    public DownKeyPressed() { this.Log('begin down key');  this.currentIndex++; this.setActiveSuggestion(this.itemsSource[this.currentIndex]);  /* Find the active suggestion in the list let activeSuggestionIndex = this.getActiveSuggestionIndex();  If not found, then activate the first suggestion if (activeSuggestionIndex === -1) { this.setActiveSuggestion(this.itemsSource[0]); return; }  if (activeSuggestionIndex === (this.itemsSource.length - 1)) { Go to the first suggestion this.setActiveSuggestion(this.itemsSource[0]); } else { Increment the suggestion index this.setActiveSuggestion(this.itemsSource[activeSuggestionIndex + 1]); } */ this.Log('end down key'); }  /** * Sets the active (highlighted) suggestion. */ public setActiveSuggestion(suggestion: any) { this.activeSuggestion = suggestion; }  /** * Gets the index of the active suggestion within the suggestions list. */ public getActiveSuggestionIndex() { let activeSuggestionIndex = -1; if (this.activeSuggestion != null) { activeSuggestionIndex = this.itemsSource.indexOf(this.activeSuggestion); } return activeSuggestionIndex; }  /* public indexOfObject(array: any[], property: string, value: string) { if (array == null || array.length === 0) return -1; let index = -1; for (let i = 0; i < array.length; i++) { if (array[i][property] != null && array[i][property] === value) { index = i; } } return index; }   public IsInputEmty(): boolean { return this.input == null || this.input.length === 0; } public inputKeyUp(event: KeyboardEvent) { Ignore TAB, UP, and DOWN since they are processed by the keydown handler if (event.which === 9 || event.keyCode === 9 || event.which === 38 || event.keyCode === 38 || event.which === 40 || event.keyCode === 40) { return; }  When the input is cleared if (!this.IsInputEmty()) { this.typeahead = ''; if (this.selectedSuggestion == null) this.populateSuggestions(); return; } else this.selectedSuggestion = null;  If the suggestion matches the input, then return if (this.selectedSuggestion != null) { if (this.selectedSuggestion[this.displayProperty] === this.input) { return; } }  If current input does not equal previous input, then populate the suggestions if (this.input !== this.previousInput) { this.previousInput = this.input; this.populateSuggestions(); this.populateTypeahead(); } }   public inputFocus(event: FocusEvent) { If the element is receiving focus and it has a selection, then clear the selection. This helps prevent partial editing  if (this.selectedSuggestion != null) { this.selectSuggestion(null); this.input = null; this.populateTypeahead(); }  Re-populate the suggestions this.populateSuggestions();  If we have suggestions if (this.suggestions.length > 0) { Set the typeahead to a slice of the first suggestion this.populateTypeahead();  Show/hide the suggestions this.areSuggestionsVisible = this.suggestions.length > 0; } } Called when a blur event is fired on the input element. */ public inputBlur(event: Event) {  this.areSuggestionsVisible = false; }  /** * Called when a mouseover event is fired on a suggestion element. */ public suggestionMouseOver(suggestion: any) { this.setActiveSuggestion(suggestion); }  /** * Called when a mousedown event is fired on a suggestion element. */ public suggestionMouseDown(suggestion: any, event: MouseEvent) { this.selectSuggestion(suggestion);  }  /** * Called when a mouseout event is fired on the suggestions element. */ public suggestionsMouseOut(event: MouseEvent) { this.setActiveSuggestion(null); } /* Handle empty input if (input == null || input.length === 0) { No input yet this.suggestions = []; this.areSuggestionsVisible = false; return; }  Check that we have data if (this.list == null || this.list.length === 0) return;  Filter the suggestions this.suggestions = this.list.filter(function(item) { return item[searchProperty].toLowerCase().indexOf(input.toLowerCase()) > -1; });  Limit the suggestions (if applicable) if (this.maxSuggestions > -1) { this.suggestions = this.suggestions.slice(0, this.maxSuggestions); }  if (this.suggestions.length === 0) { No suggestions, so clear the typeahead this.typeahead = ''; } else { Set the typeahead value this.populateTypeahead(); Make the first suggestion active this.activeSuggestion = this.suggestions[0]; }  Show/hide the suggestions this.areSuggestionsVisible = this.suggestions.length > 0; }  Sets the typeahead input element's value based on the active suggestion. */  public selectSuggestion(suggestion: any) { this.selectedItem = suggestion; this.Log('selected suggestion', suggestion); this.areSuggestionsVisible = false; if (suggestion !== null) this.OnSelectionChanged.emit(suggestion); else this.OnClearedSelectedItem.emit(); this.currentIndex = -1; /* Other form operations if (this.selectedSuggestion != null) { Set the values of the input elements Set the typeahead value this.inputFilter.setValue(this.selectedSuggestion[this.displayProperty]); todo:improve with expressions this.input = suggestion[this.displayProperty]; this.typeahead = suggestion[this.displayProperty]; Blur the input so we can "lock" the selected suggestion this.blurInputElement(); } */ } /* public populateInputFilter(element: HTMLElement) { public populateInputFilter() { let currentElement = element;  while (currentElement.nodeName !== 'A') { currentElement = currentElement.parentElement; } this.selectedSuggestionText = currentElement.innerText;  this.inputFilter.setValue(this.selectedSuggestionText); let list = this.selectedSuggestionTemplate.map( a => { return a; }); this.inputFilter.setValue(<HTMLElement>(list[0].nativeElement).innerText); }   public blurInputElement() { if (this.inputElement && this.inputElement.nativeElement) { this.inputElement.nativeElement.blur(); } }  Indicates whether a suggestion has been selected.  public hasSelection() { return this.selectedItem != null; } */ public updateSearchParameter(param: any) { this.searchParam = param; }  public Log(message = '', obj: any = {}, ) { if (this.enableLog) { console.log(message); if (obj !== {} && obj !== {}) console.log(obj); } } } 